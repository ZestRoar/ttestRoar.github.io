---
layout: post
title: 운영체제 공룡책 정리 - 챕터 1
published: true
categories: Operation System
tags: Operation System
---

조종한다.

컴퓨터 체계는 하드웨어,소프트웨어,데이터로 구성되어 있는데, 운영체제는 이를 사용하기위한 적절한 수단을 제공

운영체제는 정부와 같아서 유용한 작업을 할 수 있게 환경을 제공해줄 뿐이다.

다음은 운영체제를 바라보는 두가지 시점


1.1.1 유저 시점

사용되는 인터페이스에 따라 다양한 시점이 존재하는데, 대부분 pc앞 모니터 키보드 마우스 등 자원 독점적 시점

유저가 수행하는 일의 효율 극대화가 목표

따라 운영체제는 사용하기 쉽게 디자인되었다.(퍼포먼스에 집중, 자원 소모는 운영체제가 알아서)

독점적 시스템은 멀티보단 싱글에 최적화 되어있다.

터미널 창구 혹은 미니 컴퓨터 사용자 시점에서는 한 컴퓨터를 여러 창구에서 접근하니 자원 공유와 정보 교환이 일어날 수 있는데, 이 상황에서의 운영체제는 분배가 가장 중요해서 자원 관리를 최대화 하도록 디자인되어있다.

워크스테이션 같은경우는 목적이 있는 자원을 자유롭게 사용하되 자원 공유도 이루어져 개인 사용과 자원 관리 사이에서 적당히 타협하도록 디자인된다.

스마트폰 같은 휴대성 컴퓨터들도 있는데 유저 간섭없이 작동되도록 운영체제가 디자인 된다.


1.1.2 시스템 시점

컴퓨터 시점에서 운영체제는 자원 할당자로서 하드웨어에 속한 가장 친밀한 프로그램이다.

cpu 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등 많은 자원이 있는데 운영체제가 이를 관리한다.

운영체제는 복잡한 요구를 직면하며 이 자원들이 공정하고 효율적이게 구체적인 프로그램에 할당 되도록 관리한다.

운영체제는 컴퓨터 에러와 오용을 예방하는 조종 프로그램이다. 특히 입출력 장치 제어와 관련성이 높다.


1.1.3 운영체제 정의

운영체제 역사 생략

운영체제는 쓸만한 컴퓨팅 시스템 구축에 대한 문제 해결을 위한 합리적인 방법을 제공하기 위해 존재한다.

하드웨어도 나날히 발전하고 어플도 진화하니 뭔가 공통된 제어기능이 필요 했기에 운영체제가 생긴 것

컴퓨터가 가동되는 동안 all-time running 되는 특성을 가지는데 이를 커널이라고 부름

커널은 os와 관련있지만 필수파트는 아닌 시스템 프로그램과 os와 관련없이 모든 프로그램을 포함하는 어플 프로그램으로 나뉜다.


1.2 컴퓨터 시스템 구조

1.2.1 컴퓨터 시스템 가동

일반적인 컴퓨터는 한개이상의 중앙처리장치와 공유 메모리 접근을 위한 공통 버스를 통해 연결되어 있는 수많은 장치 컨트롤러로 구성되어 있다.

중앙처리장치와 장치 컨트롤러는 메모리 사이클을 경쟁하며 병렬적으로 실행할 수 있다.

공유메모리에 차례대로 접근하기 위해 메모리 컽느롤러는 메모리 접근을 동기화한다.

컴퓨터 부팅할때 처음에 실행되는 프로그램들이 있는데 이러한 초기화 혹은 부트스트랩 프로그램은 간단하다.

전형적으로, ROM 이나 EEPROM 등의 펌웨어에 저장되며, cpu부터 장치컨트롤러까지 초기화를 담당한다.

부트스트랩 프로그램은 os 로딩을 해야 하므로 os 커널에 위치하며 메모리에 커널을 로드한다.

커널이 로드되고 실행하면 서비스를 제공할 수 있게 된다.

커널이 가동될 대 올타임 러닝하는 시스템 프로세스 혹은 시스템 데몬은 커널 바깥에서 제공되며 부트타임에 메모리에 적재된다.

하드웨어나 소프트웨어로부터의 간섭으로 이벤트 발생이 보통 신호가 잡히게 된다.

하드웨어는 보통 시스템 버스를 통해 CPU에 신호를 보내는데, 이 때 아무때나 간섭을 일으킬 수 있다.

소프트웨어는 시스템 콜(혹은 모니터 콜)이라는 특수한 명령을 실행할 때 간섭이 일어날 수 있다.

CPU에 간섭이 일어나면 하던 것을 멈추고 바로 정해진 위치에 실행명령을 전달한다.

정해진 위치에서는 보통 간섭에 대한 서비스 경로가 저장된 시작 위치를 알 수 있다.

Interrupts는 컴퓨터 아키텍처에서 중요한 파트다.

각각 컴퓨터 디자인에는 고유의 인터럽트 메커니즘이 있지만 몇가지 공통된 기능이 존재한다.

인터럽트는 적절한 서비스 루틴에 제어를 전달해야 한다.

이러한 전달을 다루기 위한 적절한 방법은 인터럽트 정보를 검사하는 일반적인 루틴을 불러일으키는 것이다.

이 루틴은 차례대로 인터럽트-구체화 핸들러라고 부른다.

그러나 인터럽트는 빠르게 다루어야한다.

인터럽트는 로우 메모리에 포인터 보관하고 배열이나 벡터를 이용해 인덱스 붙여 관리하는데 더 알아보고 싶으면 검색하는게 좋을듯

인터럽트 아키텍처도 장치번호로 인덱스 매기고 그랬었는데 최근엔 시스템 스택에 리턴주소나 지정주소 저장하는 등 진화된 방법으로 마치 인터럽트가 발생되지 않은것 처럼 인터럽트를 처리하고 있다네엽

1.2.2 저장 구조

CPU는 메모리로부터만 명령 전달이 가능하므로 실행하려는 프로그램은 적재되어야 한다.

메인 메모리 혹은 RAM에 보통 적재하며 메인 메모리는 흔히 DRAM 반도체로서 구현된다.

ROM EEPROM 등은 상식이므로 생략

저장할때 바이트 배열로 저장되는데 적재는 램에서 cpu로 저장은 cpu에서 램으로 이동함

전형적으로 명령을 메모리로부터 가져와 명령 레지스터에 적재하는 폰 노이만 구조를 따른다.

