---
layout: post
title: 게임 AI 브레인스토밍
published: true
categories: Algorithm
tags: Game AI
permalink: /Logic/Algorithm
---

AI 프로그래밍을 할 때는 메모리나 처리 속도를 항상 신경써야 한다.

렌더링, 물리연산, 사운드, 이벤트(애니메이션) 등 동시에 수행해야 하는일이 상당한 만큼 AI 최적화는 큰 과제로 남아 있다.

 - - - 

 - 용어 설명 

에이전트 : 인공지능 알고리즘이 적용된 개체(캐릭터, 몬스터, 탈것 등 복잡한 행동 패턴이 있다면 뭐든지)

FSM : 상태(state) 기반 가장 단순한 인공지능 모델 _ 상태 기계는 유한한 상태를 가지며 동시에 하나의 상태만 지정된다.

 > 여기서 주의할 점은 FSM이 개체 당 1개라고 오해하는 경우가 있는데 개체가 복잡하면 여러개를 가지게 되는 경우가 나올 수 있다.
 
 cf) HFSM (상태 안에 또 상태가 들어있는 구조) - 구현이 간단하고 시각적이지만 유지보수적으로 좋은 구조라고 볼 수는 없다.
 
 cf) BT - 트리 구조로 보기도 좋고 고치기도 쉬운 구조이며 작업 쪼개기도 쉬움, 장점이 많다. 헤일로, GTA 등 많은 게임에서 즐겨쓰는 구조
 
 cf) 행통 트리에 조미료를 좀더 첨가하고 싶다면 Decorator Pattern을 공부해 보아라
 
Transition(전이) : state 간의 관계, fsm 에서의 화살표로 보면 된다. (state 설명은 생략합니다.)

A* : 일종의 탐색 알고리즘 _ 성능이 좋고 정확도가 높아 게임에서 널리 사용된다. 나중에 유니티 NavMesh와 비교하면서 자세히 다룰 것이다.

> 길찾기에 있어서 간단한 웨이포인트 방식과 구현이 어려운 그래프 방식 등이 있다.

NavMesh : 유니티의 네비게이션 기능으로 격자 타일 기반의 구조(그래프 방식과 유자)로 월드를 표현한다. 
 > 다량의 웨이포인트 세트가 필요한 경우 네비게이션 메시를 사용하면 많은 정보를 얻을 수 있어 편리하다.

군집 처리 : 많은 개체를 한 집단에 소속시켜 이웃 개체의 행동을 모방해 비용을 줄이는 집단 형태의 절약형 모델링

행동 트리(BT) : 태스크(task) 기반 트리 구조의 인공지능 모델

> 경우에 따라 노드를 선택하는 셀렉터 태스크, 테스트를 통해 태스크를 결정하는 시퀀스 태스크

> 동시 실행을 위한 패러렐 태스크, 단일 실행을 위한 데코레이터 태스크가 있다.

퍼지 로직 : 행동 결정을 정확한 결과가 아닌 근사치에 기반하여 내리는 로직, 참/거짓이 아닌 상황에 따른 다양한 결과를 내리고 싶을 때의 구현 방법이다.

 - - -
 
 - 기본적인 센서 시스템 개요

센서 시스템은 의사결정 시스템 중 하나로 기본 센서 시스템 개념에는 Aspect, Sense 2개의 컴포넌트가 존재한다.

Aspect는 enum 등으로 물질 구분을 위한 정보를 담는 (tag의 대용품 정도?) 클래스이다.

Sense는 Initialize(플레이어 정보 링크 등)와 UpdateSense(프레임마다 실행) 등의 메소드를 제공한다.

https://blog.naver.com/topben/221535054537 (현재는 비공개 중)

콘 형태 : 시야 시스템에서 자주 쓰는데 간단하게는 겹침확인, 복잡하게는 거리에 따라 인지 확률을 추가하여 구현이 가능하다.

구 형태 : 청각, 촉각, 후각 모델링에 자주 쓰이며 발생원의 효과 범위와 접촉원의 효과 범위를 표현한다. 구현 내용은 위와 비슷하다.

 - - - 
 
 - 길 찾기
 
 개체를 조향(운전)하는 데에 필요한 것은 웨이포인트(Vector3) 정보이다.
 
 가속 벡터를 뽑아내는 조향 알고리즘은 다음과 같다.
 
 Vector3 Steer(타겟) { 목적지 방향 벡터 계산 > 정규화 > 속도 계산 > 힘 계산 > 최종 가속도 벡터 값 리턴 }
 
 물론 웨이포인트 판정과 최종 도달에 대한 미세 조정이 필요하다.
 
 또한 중간에 장애물(Obstacle)이 있다면 해당 장애물의 법선벡터(hit.Normal)를 구하여 이동시키면 된다.
 
 여기서 y값은 0으로 두어야 한다.

 만약 단 한번의 검사로만 처리되도록 놔둔다면 벽 집고 한 방향으로만 가는 식으로 구현되어 막혀있는 부분에서는 갈피를 못잡을 것이고, 
 
 몇번의 검사를 거친다 하더라도 스타크래프트1의 인공지능 꼴이 될 수가 있다.
 
 프로그래머는 로직에 있어서 전지적이다. 즉, 미로를 탐색할 때 해매지 않게 정확한 방향을 제시할 수 있다.
 
 A* 알고리즘은 이러한 환경에서 단순하며 효율적이다.
 
  1. 맵을 운행 가능한 데이터 구조로 표현한다.
  
  2. 출발점을 기준으로 갈 수 있는 경로에 대해 비용을 매긴다. (여기서 목적지인지 닫힌경로인지 체크를 한다.)
  
  3. 최종적으로 목적지 경로로 설정된 여러 부분에 대해 가장 낮은 비용을 선택한다면 그것이 최단 경로가 된다.
  
  4. 목적지 경로가 존재하지 않다면 유효한 경로가 없다는 것이다.
  
  5. 해당 경로에 대해 목적지에서 출발점까지 역추적하여 경로 정보를 얻는다.
 
 
 
 
 - 
